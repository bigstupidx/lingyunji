using System.Collections.Generic;using UnityEngine;using UnityEngine.Rendering;


namespace Eyesblack.EditorTools{	public class ObjectUtils	{		// 搜索指定名字的Object并返回. depthFirst是否深度优先, 否就是广度优先		public static Transform FindChildByName(Transform obj, string name, bool depthFirst)		{			//if (name == null || name == "")			//	return null;			if (!depthFirst)			{				Transform trs = obj.Find(name);				if (trs != null)				{					return trs;				}			}			for (int i = 0; i < obj.childCount; i++)			{				Transform childTransform = obj.GetChild(i);				if (depthFirst)				{					if (childTransform.name == name)					{						return childTransform;					}				}				Transform resTransform = FindChildByName(childTransform, name, depthFirst);				if (resTransform != null)				{					return resTransform;				}			}			return null;		}        // 以某gameObject为根节点，遍历搜索某名字的某组件.        static public T FindComponent<T>(GameObject root, string name) where T : MonoBehaviour        {            T ret = null;            GameObject target = FindGameObject(root, name);            if (target != null)                ret = target.GetComponent<T>();            return ret;        }        // 以某gameObject为根节点，遍历搜索某名字的子物体.        static public GameObject FindGameObject(GameObject root, string name)        {            GameObject ret = null;            Transform[] children = root.GetComponentsInChildren<Transform>(true);            int nCount = children.Length;            for (int i = 0; i < nCount; i++)            {                if (string.Compare(name, children[i].name) == 0)                    ret = children[i].gameObject;            }            return ret;        }        public static Transform FindChildByName(Transform obj, string name)		{			return FindChildByName(obj, name, false);		}		// 获取obj到sinceParent的层级路径。		public static string GetTransformPath(Transform obj, Transform sinceParent)		{			if (obj == sinceParent)				return "";			string path = obj.name;			Transform objParent = obj.parent;			while (objParent != null && objParent != sinceParent)			{				path = objParent.name + "/" + path;				objParent = objParent.parent;			}			return path;		}		public static void SetLayerRecursively(GameObject obj, int newLayer)		{			if (obj == null)				return;			obj.layer = newLayer;						for (var i=0; i<obj.transform.childCount; ++i)			{				var child = obj.transform.GetChild(i);				SetLayerRecursively( child.gameObject, newLayer );			}		}		public static void OptimizeParticleSystems(GameObject obj)		{			if (obj == null)				return;			ParticleSystemRenderer[] psrList = obj.GetComponentsInChildren<ParticleSystemRenderer>();			for (var i = 0; i < psrList.Length; ++i)			{				var pr = psrList[i];				pr.shadowCastingMode = ShadowCastingMode.Off;				pr.receiveShadows = false;			}		}        public static GameObject AddChild(Transform parent, GameObject prefab)        {            if (parent == null || prefab == null)            {                return null;            }            GameObject go = GameObject.Instantiate(prefab) as GameObject;            go.transform.SetParent(parent);            go.transform.localPosition = Vector3.zero;            go.transform.localScale = Vector3.one;            go.transform.localRotation = Quaternion.identity;            go.layer = parent.gameObject.layer;            return go;        }		public static void DestroyAllChildren(Transform parent)		{			// fast check			if (parent.childCount == 0)				return;			var children = new GameObject[parent.childCount];			for (int i = 0; i < parent.childCount; i++) {				var child = parent.GetChild(i);				children[i] = child.gameObject;			}			for (int i = 0; i < children.Length; i++) {				if (Application.isPlaying)					GameObject.Destroy(children[i]);				else					GameObject.DestroyImmediate(children[i]);			}		}		public static void RemoveAllChild(Transform parent)        {            if (parent == null)            {                return;            }            for (int i = 0; i < parent.childCount; ++i)            {                GameObject go = parent.GetChild(i).gameObject;                GameObject.Destroy(go);            }        }#if UNITY_EDITOR		public static void AddSelection(UnityEngine.Object obj)		{			if (UnityEditor.Selection.Contains(obj) == false)			{				UnityEngine.Object[] objects = UnityEditor.Selection.objects;				UnityEngine.Object[] newObjects = new GameObject[objects.Length + 1];				//Object activeObject = UnityEditor.Selection.activeObject;				for (int i = 0; i < objects.Length; i++)				{					newObjects[i] = objects[i];				}				newObjects[objects.Length] = obj;				UnityEditor.Selection.objects = newObjects;				//UnityEditor.Selection.activeObject = activeObject;			}		}		public static void RemoveSelection(UnityEngine.Object obj)		{			if (UnityEditor.Selection.Contains(obj) == true)			{				UnityEngine.Object[] objects = UnityEditor.Selection.objects;				UnityEngine.Object[] newObjects = new GameObject[objects.Length - 1];				for (int i = 0, j = 0; i < objects.Length; i++)				{					if (objects[i] != obj)					{						newObjects[j] = objects[i];						j++;					}				}				UnityEditor.Selection.objects = newObjects;			}		}#endif		public static GameObject[] GetGameObjectsByLayer(int layer)		{			GameObject[] goArray = GameObject.FindObjectsOfType<GameObject>();			List<GameObject> goList = new List<GameObject>();			for (var i = 0; i < goArray.Length; i++)			{				if (goArray[i].layer == layer)				{					goList.Add(goArray[i]);				}			}			return goList.ToArray();		}		public static void SetHideFlagsRecursively(GameObject obj, HideFlags flags)		{			if (obj == null)				return;			obj.hideFlags = flags;			for (var i = 0; i < obj.transform.childCount; ++i) {				var child = obj.transform.GetChild(i);				SetHideFlagsRecursively(child.gameObject, flags);			}		}		public static string GetUniqueChildName(GameObject obj, string name)		{			if (!obj)				return name;			var transform = obj.transform;			for (int i=0; true; i++) {				string find = i == 0 ? name : name + " (" + i.ToString() + ")";				if (!transform.Find(find))					return find;			}		}	}}